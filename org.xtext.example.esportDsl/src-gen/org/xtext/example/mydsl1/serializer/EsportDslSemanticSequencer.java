/*
 * generated by Xtext 2.12.0
 */
package org.xtext.example.mydsl1.serializer;

import com.google.inject.Inject;
import eSport.Capacity;
import eSport.Coach;
import eSport.Country;
import eSport.ESportPackage;
import eSport.FinalStage;
import eSport.Group;
import eSport.GroupStage;
import eSport.League;
import eSport.Match;
import eSport.Player;
import eSport.Qualification;
import eSport.Root;
import eSport.Team;
import eSport.Tournament;
import eSport.Zone;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl1.services.EsportDslGrammarAccess;

@SuppressWarnings("all")
public class EsportDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private EsportDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ESportPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ESportPackage.CAPACITY:
				sequence_Capacity(context, (Capacity) semanticObject); 
				return; 
			case ESportPackage.COACH:
				sequence_Coach(context, (Coach) semanticObject); 
				return; 
			case ESportPackage.COUNTRY:
				sequence_Country(context, (Country) semanticObject); 
				return; 
			case ESportPackage.FINAL_STAGE:
				sequence_FinalStage(context, (FinalStage) semanticObject); 
				return; 
			case ESportPackage.GROUP:
				sequence_Group(context, (Group) semanticObject); 
				return; 
			case ESportPackage.GROUP_STAGE:
				sequence_GroupStage(context, (GroupStage) semanticObject); 
				return; 
			case ESportPackage.LEAGUE:
				sequence_League(context, (League) semanticObject); 
				return; 
			case ESportPackage.MATCH:
				sequence_Match(context, (Match) semanticObject); 
				return; 
			case ESportPackage.PLAYER:
				sequence_Player(context, (Player) semanticObject); 
				return; 
			case ESportPackage.QUALIFICATION:
				sequence_Qualification(context, (Qualification) semanticObject); 
				return; 
			case ESportPackage.ROOT:
				sequence_Root(context, (Root) semanticObject); 
				return; 
			case ESportPackage.TEAM:
				sequence_Team(context, (Team) semanticObject); 
				return; 
			case ESportPackage.TOURNAMENT:
				sequence_Tournament(context, (Tournament) semanticObject); 
				return; 
			case ESportPackage.ZONE:
				sequence_Zone(context, (Zone) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Capacity returns Capacity
	 *
	 * Constraint:
	 *     (type=CapacityType value=EInt)
	 */
	protected void sequence_Capacity(ISerializationContext context, Capacity semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ESportPackage.Literals.CAPACITY__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ESportPackage.Literals.CAPACITY__TYPE));
			if (transientValues.isValueTransient(semanticObject, ESportPackage.Literals.CAPACITY__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ESportPackage.Literals.CAPACITY__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCapacityAccess().getTypeCapacityTypeEnumRuleCall_3_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getCapacityAccess().getValueEIntParserRuleCall_4_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Person returns Coach
	 *     Coach returns Coach
	 *
	 * Constraint:
	 *     (name=EString age=EInt country=[Country|EString] description=EString? (capacities+=Capacity capacities+=Capacity*)?)
	 */
	protected void sequence_Coach(ISerializationContext context, Coach semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Country returns Country
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_Country(ISerializationContext context, Country semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ESportPackage.Literals.COUNTRY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ESportPackage.Literals.COUNTRY__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCountryAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FinalStage returns FinalStage
	 *
	 * Constraint:
	 *     (maxNbGames=EInt teams+=[Team|EString] teams+=[Team|EString]* (matchs+=Match matchs+=Match*)?)
	 */
	protected void sequence_FinalStage(ISerializationContext context, FinalStage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GroupStage returns GroupStage
	 *
	 * Constraint:
	 *     (type=GroupStageType maxNbGames=EInt meetingsInSameGroup=EInt meetingsWithOtherGroups=EInt? (groups+=Group groups+=Group*)?)
	 */
	protected void sequence_GroupStage(ISerializationContext context, GroupStage semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Group returns Group
	 *
	 * Constraint:
	 *     (teams+=[Team|EString] teams+=[Team|EString]* (matchs+=Match matchs+=Match*)?)
	 */
	protected void sequence_Group(ISerializationContext context, Group semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     League returns League
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         size=EInt 
	 *         year=EInt 
	 *         season=Season 
	 *         zone=[Zone|EString]? 
	 *         (qualifiesFor+=[Qualification|EString] qualifiesFor+=[Qualification|EString]*)? 
	 *         groupstage=GroupStage?
	 *     )
	 */
	protected void sequence_League(ISerializationContext context, League semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Match returns Match
	 *
	 * Constraint:
	 *     (type=MatchType loserWins=EInt teamWinner=[Team|EString] teamLoser=[Team|EString])
	 */
	protected void sequence_Match(ISerializationContext context, Match semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ESportPackage.Literals.MATCH__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ESportPackage.Literals.MATCH__TYPE));
			if (transientValues.isValueTransient(semanticObject, ESportPackage.Literals.MATCH__LOSER_WINS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ESportPackage.Literals.MATCH__LOSER_WINS));
			if (transientValues.isValueTransient(semanticObject, ESportPackage.Literals.MATCH__TEAM_WINNER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ESportPackage.Literals.MATCH__TEAM_WINNER));
			if (transientValues.isValueTransient(semanticObject, ESportPackage.Literals.MATCH__TEAM_LOSER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ESportPackage.Literals.MATCH__TEAM_LOSER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMatchAccess().getTypeMatchTypeEnumRuleCall_3_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getMatchAccess().getLoserWinsEIntParserRuleCall_4_0(), semanticObject.getLoserWins());
		feeder.accept(grammarAccess.getMatchAccess().getTeamWinnerTeamEStringParserRuleCall_5_0_1(), semanticObject.eGet(ESportPackage.Literals.MATCH__TEAM_WINNER, false));
		feeder.accept(grammarAccess.getMatchAccess().getTeamLoserTeamEStringParserRuleCall_6_0_1(), semanticObject.eGet(ESportPackage.Literals.MATCH__TEAM_LOSER, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Person returns Player
	 *     Player returns Player
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         age=EInt 
	 *         country=[Country|EString] 
	 *         position=Position? 
	 *         description=EString? 
	 *         (capacities+=Capacity capacities+=Capacity*)?
	 *     )
	 */
	protected void sequence_Player(ISerializationContext context, Player semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Qualification returns Qualification
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_Qualification(ISerializationContext context, Qualification semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ESportPackage.Literals.QUALIFICATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ESportPackage.Literals.QUALIFICATION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getQualificationAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Root returns Root
	 *
	 * Constraint:
	 *     (
	 *         zones+=Zone | 
	 *         tournaments+=Tournament | 
	 *         leagues+=League | 
	 *         teams+=Team | 
	 *         persons+=Person | 
	 *         qualifications+=Qualification | 
	 *         countries+=Country
	 *     )+
	 */
	protected void sequence_Root(ISerializationContext context, Root semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Team returns Team
	 *
	 * Constraint:
	 *     (name=EString championshipPoints=EInt coach=Coach? players+=Player players+=Player*)
	 */
	protected void sequence_Team(ISerializationContext context, Team semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Tournament returns Tournament
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         size=EInt 
	 *         type=TournamentType 
	 *         year=EInt 
	 *         allowedZones+=[Zone|EString] 
	 *         allowedZones+=[Zone|EString]* 
	 *         (countries+=[Country|EString] countries+=[Country|EString]*)? 
	 *         qualifiesFor=[Qualification|EString]? 
	 *         (qualifiesFrom+=[Qualification|EString] qualifiesFrom+=[Qualification|EString]*)? 
	 *         (finalstages+=FinalStage finalstages+=FinalStage*)? 
	 *         (groupstages+=GroupStage groupstages+=GroupStage*)?
	 *     )
	 */
	protected void sequence_Tournament(ISerializationContext context, Tournament semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Zone returns Zone
	 *
	 * Constraint:
	 *     (name=EString countries+=Country countries+=Country* (teams+=Team teams+=Team*)?)
	 */
	protected void sequence_Zone(ISerializationContext context, Zone semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
